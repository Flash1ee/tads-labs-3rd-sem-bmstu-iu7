# Лабораторная работа №2 "Записи с вариантами, обработка таблиц"
**Студент** Варин Дмитрий Владимирович  
**Группа** ИУ7-36Б
## Описание условия задания
Создать таблицу, содержащую не менее 40-ка записей (тип – запись с вариантами  (объединениями)).  
Упорядочить данные в  нейпо  возрастанию  ключей, двумя  алгоритмамисортировки, где ключ – любое невариантное поле(по выбору программиста), используя:  
- саму таблицу
- массив ключей  
Ввести  репертуар  театров,  содержащий :   
- название  театра
- спектакль
- режиссер
- диапазон  цены  билета  
Тип  спектакля: 
- детский –для  какого  возраста,  тип  (сказка,  пьеса);
- взрослый –пьеса,  драма,  комедия);
- музыкальный –композитор,  страна, минимальный возраст, продолжительность).  
Вывести список всех музыкальных  спектаклей  для  детей  указанного  возраста  с продолжительностью меньше указанной.  

## Техническое задание  
### Входные данные:
1. **Файл с данными** : 
- *текстовый файл*, каждое поле записи на новой строке. Каждая запись с новой строки.  
2. **Целое число - номер команды**: 
- целое число от 0 до 13.
3. **Дополнение**: 
- в зависимости от вводимых данных - целочисленное или строковое значение.

### Используемые сортировки  
*В качестве сортировки с асимптотической сложностью O(n^2) - медленная,*  
*используется сортировка пузырьком, с O(nlog(n)) –быстрая-  алгоритм quick sort*    

### Выходные данные:
1. **Полученная таблица** (основная или таблица ключей) в отсортированном или неотсортированном виде (в зависимости от выполненной команды).
2. Количественная характеристика **сравнения вариантов сортировки таблицы**.
### Функция программы:
Программа выполняет ряд функций, указанных при её запуске.   
**Она запускает**:  

0. Завершить выполнение
1. Загрузка данных из файла.
2. Добавить запись в таблицу с клавиатуры.
3. Удалить запись из таблицы.
4. Отсортировать таблицу ключей O(n^2).
5. Отсортировать исходную таблицу O(n^2).
6. Отсортировать таблицу ключей O(N*log(N)).
7. Отсортировать исходную таблицу О(N*log(N)).
8. Вывести исходную таблицу.
9. Вывести таблицу ключей.
10. Вывести список музыкальных спектаклей для детей указанного возраста с продолжительностью меньше указанной.
11. Перемешать таблицу.
12. Вывести сравнение сортировок с сложностями О(n*log(N)).
13. Вывести сравнение сортировок с сложностями О(n^2).

*В качестве сортировки с асимптотической сложностью O(n^2) используется сортировка пузырьком, с O(nlog(n)) – алгоритм быстрой сортировки*  

### Обращение к программе
Запускается из терминала.

### Аварийные ситуации
1. Некорректный ввод номера команды.  
*На входе*: число, не входящее в диапазон команд.   
*На выходе*: сообщение «Такого режима нет в программе, повторите попытку...»   
2. Некорректный ввод строки с именем файла или файл пуст.  
*На входе*: строка с полным путем к файлу, относительно текущей директории.  
*На выходе*: сообщение «Не удалось открыть файл.»   
3. Выполнение какой-либо команды до выгрузки файла.  
*На входе*: целое число в диапазоне от 2 до 12 (номер команды).  
*На выходе*: сообщение «Исходная таблица пуста»  
4. Превышение количества записей в конечной таблице.  
*На входе*: добавление новой записи при максимальном размере таблицы.  
*На выходе*: сообщение «Достигнут максимальный размер таблицы!»  
5. Неверный ввод строкового поля.  
*На входе*: строка, содержащая некорректные строковые литералы.    
*На выходе*: «Ошибка добавления».  
6. Ввод недопустимого признака поля.  
*На входе*: целое число, отличающееся от обусловленных допустимых значений для поля.  
*На выходе*: сообщение «Ошибка добавления!»  
7. Удаления несуществующей записи  
*На входе*: целое число, id исходной таблицы.  
*На выходе*: сообщение «Введённый id не найден в таблице»  
8. Удаление записи из пустой таблицы  
*На входе*: целое число, id исходной таблицы. 
*На выходе*: сообщение «Таблица пуста» 
9. Превышение количества записей в конечной таблице.  
*На входе*: добавление новой записи при максимальном размере таблицы.  
*На выходе*: сообщение «Невозможно записать в таблицу данные,размер превышает MAX»  

### Структуры данных
Для хранения одной записи таблицы используется структура `theatre_t`, состоящая из общих полей всех записей `id`, `title`, `show`, `producer`, `min_price`, `max_price`, `category`.  
В структуре используется вариативная часть, представленная объединением `union choice`,   
состоящим из структур `child`, `adult`, `music`.
```C
#define TITLE 32
#define SHOW 32
#define NAME 32

typedef struct
{
    int id;
    char title[TITLE + 3];
    char show[SHOW + 3];
    char producer[NAME + 3];
    int min_price;
    int max_price;
    int8_t category;
    union
    {
        child minor;
        adult major;
        music sound;
    } choice;
} theatre_t;
```
Вариативная часть представленна следующими структурами :
```C
#define TYPE 16

typedef struct
{
    int8_t min_age;
    int8_t type;
    char genre[TYPE];
} child

typedef struct
{
    int8_t type;
    char genre[TYPE];
} adult;

typedef struct
{
    char composer[NAME + 3];
    char country[COUNTRY + 3];
    int min_age;
    int time;
} music;

```
Таблица ключей хранится в структуре `theatre_key_t`, хранящая ключевое поле - min_price и индекс исходной таблицы.  
```c
typedef struct 
{
    int min_price;
    int id;
} theatre_key_t;

```
*Поля структур описаны в условии задания*  
Также используются перечисления `enum` для определения значения строковых переменных,   
описанных в условии.  
```c
typedef enum
{
    FAIRY_TALE,
    PIECE,
    DRAMA,
    COMEDY
} GENRE;

typedef enum
{
    KIDS,
    ADULTS,
    MUSIC
} CATEGORY;
```
По выбранному пользователем жанру в поле `genre` структур `child`, `adult` записываются   
следующие значения :
```c
const char *genre[] = {
    "Fairy tale",
    "Piece",
    "Drama",
    "Comedy"};

```
### Алгоритм
1. Пользователь вводит номер команды из меню.
2. Пока пользователь не введет 0 (выход из программы) или не совершит ошибку ввода, ему будет предложено выполнять действия с таблицей.  

### Оценка эффективности 
Измерения эффективности сортировок будут производиться в микросекундах.  
Для измерения используется структура `timeval` из библиотеки `<sys/time.h>`.  
При записи результатов использовалось среднее время, полученное по результатам 10 измерений.  
  
**Время сортировки**

                      Сортировка пузырьком                         Быстрая сортировка
| Количество записей | Исходная таблица | Таблица ключей | Исходная таблица | Таблица ключей |
|--------------------|------------------|----------------|------------------|----------------|
| 20                 | 4.1              | 1.9            | 1.6              | 1.2            |
| 50                 | 26.9             | 7.5            | 2.8              | 2.0            |
| 100                | 66.8             | 24.8           | 6.2              | 4.3            |
| 200                | 248.8            | 83.7           | 14.1             | 9.0            |
| 400                | 1036.2           | 298.1          | 22.4             | 18.7           |
| 800                | 4089.9           | 1156.7         | 46.8             | 32.5           |
| 4000               | 100729.3         | 26880.5        | 312.1            | 208.0          |
| 8000               | 419431.4         | 96695.5        | 602.3            | 350.1          |
| 10000              | 637660.9         | 150583.5       | 740.6            | 440.0          |
  
**Объём занимаемой памяти (в байтах)**

| Количество записей | Исходная таблица | Таблица ключей |
|--------------------|------------------|----------------|
| 20                 | 3760             | 160            |
| 50                 | 9400             | 400            |
| 100                | 18800            | 800            |
| 200                | 37600            | 1600           |
| 400                | 75200            | 3200           |
| 800                | 150400           | 6400           |
| 4000               | 752000           | 32000          |
| 8000               | 1504000          | 64000          |
| 10000              | 1880000          | 80000          |


**Таблица сравнения эффективности сортировок массива ключей и исходной таблицы**  
| Кол-во | Соотнош-е заним. памяти | Рост скор. сорт-ки ключей<br> в срав. с табл. O(n^2) | Рост скор. сор-ки <br> ключей в срав. с табл. O(n*log(n)) |
|--------|-------------------------|------------------------------------------------------|-----------------------------------------------------------|
| 20     | ~4.25%                  | ~2 раза                                              | ~1.3 раза                                                 |
| 50     | ~4.25%                  | ~3.5 раза                                            | ~1.4 раза                                                 |
| 100    | ~4.25%                  | ~2.7 раза                                            | ~1.5 раза                                                 |
| 200    | ~4.25%                  | ~3 раза                                              | ~1.6 раза                                                 |
| 400    | ~4.25%                  | ~3.5 раза                                            | ~1.2 раза                                                 |
| 800    | ~4.25%                  | ~3.5 раза                                            | ~1.5 раза                                                 |
| 4000   | ~4.25%                  | ~3.8 раза                                            | ~1.5 раза                                                 |
| 8000   | ~4.25%                  | ~4.3 раза                                            | ~1.7 раза                                                 |
| 10000  | ~4.25%                  | ~4.3 раза                                            | ~1.7 раза                                                 |


**Таблица сравнения сортировок массива ключей и исходной таблицы**  
Во сколько раз сортировка сложности O(n*log(n)) быстрее O(n^2)?  

| Кол-во | Массив ключей | Таблица     |
|--------|---------------|-------------|
| 20     | ~1.6 раза     | ~2.6 раза   |
| 50     | ~9.6 раза     | ~3.75 раза  |
| 100    | ~10.8 раза    | ~5.8 раза   |
| 200    | ~17.7 раза    | ~9.3 раза   |
| 400    | ~46.3 раза    | ~16 раз     |
| 800    | ~87.4 раза    | ~35.6 раза  |
| 4000   | ~322.8 раза   | ~129.2 раза |
| 8000   | ~696.4 раза   | ~276.2 раза |
| 10000  | ¬909.6 раза   | ~342.2 раза |


### Контрольные вопросы

1. **Как выделяется память под вариантную часть записи?**  
Размер памяти, выделяемый под вариативную часть, равен максимальному по размеру  
полю вариативной части.  

2. **Что будет, если в вариантную часть ввести данные, не соответсвтующие описанным?**     
Если в вариативную часть ввести данные, не соответствующие описанным, то нельзя  
точно сказать, что произойдёт, для таких случаев используется термин `неопределённое поведение`.

3. **Кто должен следить за правильностью выполнения операций с вариантной частью записи?**  
Контроль за правильностью выполнения операций с вариантной частью записи возлагается на программиста.

4. **Что представляет собой таблица ключей, зачем она нужна?**  
Дополнительный массив (структура), содержащий индекс элемента в исходной  
таблице  и выбранный ключ. Она нужна для оптимизации сортировки.  

5. **В каких случаях эффективнее обрабатывать данные в самой таблице, а когда – использовать таблицу ключей?**  
В случае, если мы сортируем таблицу ключей, мы экономим время, так как перестановка записей в исходной таблице,  
которая может содержать большое количество полей, отсутствует.Но для размещения таблицы ключей требуется дополнительная память.  
Кроме того, если в качестве ключа используется символьное поле записи, то для сортировки таблицы ключей необходимо дополнительно обрабатывать данное поле в цикле, следовательно, увеличивается время выполнения а также увеличивается размер массива ключей, что уменьшает эффективность сортировки засчёт выделения доп. памяти.  
Если исходная таблица содержит небольшое число полей, то выгоднее обрабатывать данные в самой таблице.  

6. **Какие способы сортировки предпочтительнее для обработки таблиц и почему?**  
Если обработка производится в таблице, то необходимо использовать алгоритмы сортировки, требующие наименьшее количество операций перестановки.  
Если сортировка производится по таблице ключей, эффективнее использовать сортировки с наименьшей сложностью работы.  

### Вывод
Чем больше количество записей таблицы, тем эффективнее сортировка массива ключей.  
Сравнительная таблица показывает рост скорости выполнения сортировки О(n^2) до 4х раз, быстрой О(n*log(n)) до 1.7 раза.   
Однако и на маленьких размерах таблицы, сортировка ключей происходит быстрее, чем сортировка самой таблицы.  
Но стоит заметить, что для хранения ключей необходима дополнительная память.   
В данной работе для массива ключей выделялось `~4.25%` памяти относительно исходной таблицы, что   
позволяло использовать эффективность выделения доп. памяти для сортировки таблицы по ключам.   
Использование массива ключей неэффективно при использовании на малых размерах исходной таблицы,  
как показывают замеры ключи сортируются в 2-3 раза быстрее при сортировки О(n^2) и в 1-2 раза при O(n*logn(n)), однако  
увеличении количества записей разрыв увеличивается в быстрой сортировке до 4х раз, быстрая всё также сортирует ~ в 2 раза быстрее.  
Кроме того, удалось на практике убедиться в зависимости скорости сортировок, представленной в О нотации,  
при использовании на данных. Скорость отличается при количестве в 10000 записей до 900 раз при сортировке массива ключей!     
Быстрая сортировка O(n*log(n)) в разы быстрее O(n^2), что показывает сравнительная таблица.  
